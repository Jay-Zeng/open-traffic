package netconfig.Datum;

import java.io.Serializable;

import netconfig.Link;
import netconfig.NetconfigException;
import netconfig.Spot;
import bots_math.ImmutableTensor1;
import core.Coordinate;
import core.Time;
import com.google.common.collect.ImmutableList;

/**
 * The main representation of path inference data input. Each instance is based
 * on one Coordinate (and Time) and an array of spots that it may map to. The
 * probability array is <u>always</u> the same length as spots and defaults to
 * all -1~s, which causes the hasValidProbabilites function to return false
 * without having to transverse the array.
 * <p/>
 * Every user of path inference should use (or subclass) this structure, noting
 * that there are several fields in this class that are optional, i.e. they
 * could be null, so the need for subclasses should be minimized.
 * <p/>
 * In order to use the path inference all the non-optional fields are needed
 * (you can't construct an instance without these):
 * <ul>
 * <li>coordinate</li>
 * <li>time</li>
 * <li>id (null is not allowed).</li>
 * <li>spots (null spots not allowed).</li>
 * </ul>
 * The probabilities are set to an invalid value. (Which can be changed
 * individually, but the whole field is final so the length (or the Array class
 * it points to) cannot.)
 * <p/>
 * Link is because Spot takes it as a parameter.
 * 
 * @param <LINK>
 *            the type of link.
 * @author tjhunter
 */
public class ProbeCoordinate<LINK extends Link> implements Serializable {

    /**
     * The precision of the probability vector.
     * 
     * All probability values, including the sign tests, should be tested
     * against this threshold value.
     * 
     * All averaging of probabilities should be also tested against this value.
     * (Which implies all sums should be tested against this value multiplied by
     * the number of elements in the sum).
     */
    public static final double probabilityPrecision = 1e-4;
    /**
     * Autogenerated serial ID.
     */
    private static final long serialVersionUID = 4L;
    /** ID of this particular driver, cannot be null. */
    private final String id_;
    /** Date &amp; time of the measurement (coordinate). */
    private final Time time_;
    /** Original coordinate (measurement), spots based on this. */
    private final Coordinate coordinate_;
    /** Map-matched spots (maybe 0-length, but never null). */
    private final ImmutableList<Spot<LINK>> spots_;
    /**
     * Probability distribution over the projection spots.
     * <p/>
     * This array is the same length as the spots array and each index
     * corresponds to the spot with the same index in the spots array.
     * <p/>
     * Use {@link #hasValidProbabilities(double)} to see if it contains a valid
     * distribution If you need to update the probabilities, use th updated()
     * methods. It is not recommended to update the data in place..
     */
    private final ImmutableTensor1 probabilities_;
    // Optional fields
    /**
     * Optional: null is unknown or NA.
     * <p/>
     * In meters per second.
     */
    private final Float speed_;
    /**
     * Optional: null is unknown or NA.
     * <p/>
     * In easterly degrees from North.
     */
    private final Short heading_;
    /** Optional: null is unknown or NA. */
    private final Boolean hired_;
    /**
     * Optional: null is unknown or NA.
     * <p/>
     * Unit-less horizontal dilution of position.
     */
    private final Float hdop_;

    private ProbeCoordinate(String id, Time time, Coordinate coordinate,
            ImmutableList<Spot<LINK>> spots, ImmutableTensor1 probabilities,
            Float speed, Short heading, Boolean hired, Float hdop) {
        this.id_ = id;
        this.time_ = time;
        this.coordinate_ = coordinate;
        this.spots_ = spots;
        this.probabilities_ = probabilities;
        this.speed_ = speed;
        this.heading_ = heading;
        this.hired_ = hired;
        this.hdop_ = hdop;
    }

    /**
     * Returns a copy of this probe coordinate object with a new set of
     * projections )spots).
     * 
     * The previous probability distribution is not copied over. It is
     * initialized to an empty distribution.
     * 
     * @param new_spots
     *            the new spots. They can have a different size from the
     *            original spot distribution.
     * @return
     * @throws NetconfigException
     */
    public <LINK2 extends Link> ProbeCoordinate<LINK2> reprojected(
            Spot<LINK2>[] new_spots) throws NetconfigException {
        return ProbeCoordinate.from(id(), time(), coordinate(), new_spots,
                speed(), heading(), hired(), hdop());
    }

    /**
     * Returns a copy of this probe coordinate object with a new set of
     * projections and a net set of probabilities.
     * 
     * It does not modify the original object.
     * 
     * @param new_spots
     *            the new spots. They can have a different size from the
     *            original spot distribution.
     * @return
     * @throws NetconfigException
     */
    public <LINK2 extends Link> ProbeCoordinate<LINK2> clone(
            Spot<LINK2>[] new_spots, double[] new_probabilities)
            throws NetconfigException {
        return ProbeCoordinate.from(id(), time(), coordinate(), new_spots,
                new_probabilities, speed(), heading(), hired(), hdop());
    }

    /**
     * Returns a copy of this probe coordinate object with a new set of
     * probabilities.
     * 
     * @param new_probabilities
     *            The updated vector of probabilities.
     * @return
     * @throws NetconfigException
     */
    public ProbeCoordinate<LINK> clone(double[] new_probabilities)
            throws NetconfigException {
        ImmutableTensor1 new_probs = PathInference
                .buildProbabilities(new_probabilities);
        return new ProbeCoordinate<LINK>(id(), time(), coordinate(), spots(),
                new_probs, speed(), heading(), hired(), hdop());
    }

    /**
     * Returns a copy of this probe coordinate object with a new timestamp.
     * 
     * WARNING: this is dangerous if you work with a database, you will not be
     * able to recover the point in the database.
     * 
     * Used in the path inference filter to guarantee that all points have a
     * distinct timestamp per driver.
     * 
     * @param new_time
     *            the new timestamp.
     * @return
     * @throws NetconfigException
     */
    public ProbeCoordinate<LINK> clone(Time new_time) throws NetconfigException {
        return new ProbeCoordinate<LINK>(id(), new_time, coordinate(), spots(),
                probabilities(), speed(), heading(), hired(), hdop());
    }

    /**
     * Helper function in case one wants both the most probable spot and the
     * corresponding probability, see {@link #getMostProbableSpot()} for a list
     * of caveats and the ordering.
     * 
     * @return the index of the most probable spot/probability, or null if there
     *         are no spots.
     * @see #getMostProbableSpot()
     * @see #sortByDescendingProbabilities()
     */
    public Integer getMostProbableIndex() {
        double lastMax = Double.NEGATIVE_INFINITY;
        Integer ret = null;
        // Won't loop at all if length == 0
        for (int i = 0; i < this.spots().size(); i++) {
            // Use compare() b/c the operators don't handle some edge cases,
            // namely NaN, +/- Inf, and -0.0.
            if (0 < Double.compare(this.probabilities().get(i), lastMax)) {
                lastMax = this.probabilities().get(i);
                ret = i;
            }
        }
        return ret;
    }

    /**
     * Get the most probable map-matched spot (or null) without checking if the
     * probabilities array is valid and does not do any reordering. If you are
     * going to call this more than once, it may be better to call
     * {@link #sortByDescendingProbabilities()} and refer to the zeroth element
     * of the spots array thereafter.
     * <p/>
     * Sorting of the probabilities is like:<br/>
     * -Inf &lt; [negVal] &lt; -0 &lt; 0 &lt; [posVal] &lt; Inf &lt; NaN
     * 
     * @return the one most likely map-matched spot, or null if the spots array
     *         is 0-length (does not check for a valid probabilities array).
     * @see #sortByDescendingProbabilities()
     * @see #getMostProbableIndex()
     */
    public Spot<LINK> getMostProbableSpot() {
        Integer idx = this.getMostProbableIndex();
        if (null != idx) {
            return this.spots().get(idx);
        } else {
            return null;
        }
    }

    public Time getTime() {
        return this.time();
    }

    /**
     * Returns, if possible, a logically equivalent timed spot.
     * 
     * @return a timed spot
     * @throws NetconfigException
     *             if this probe coordinate has more than one spot.
     */
    public TSpot<LINK> toTSpot() throws NetconfigException {
        if (this.spots().size() != 1) {
            throw new NetconfigException(null, "Wrong number of spots in "
                    + this);
        }
        if (spots().get(0) == null) {
            throw new NetconfigException(null, "Null spot in " + this);
        }
        return new TSpot<LINK>(spots().get(0), id(), time(), hired(), speed());
    }

    /**
     * @return a string representation of this ProbeCoordinate instance.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("%s at %s by %s [\n", this.coordinate()
                .toString(), this.time().toString(), this.id()));
        for (int i = 0; i < this.spots().size(); i++) {
            double distance = -1;
            try {
                distance = this.spots().get(i).toCoordinate()
                        .distanceVincentyInMeters(coordinate());
            } catch (Exception e) {
            }
            sb.append(String.format("\t\t%f\t%s\t%f\n", this.probabilities()
                    .get(i), this.spots().get(i).toString(), distance));

        }
        sb.append(String.format(
                // Use %s so null will print null (even in the boolean).
                "]  %s m/s  %s degrees  hired = %s  hdop = %s", this.speed(),
                this.heading(), this.hired(), this.hdop()));
        return sb.toString();
    } // toString.

    // ************ PUBLIC CONSTRUCTORS *************
    /**
     * Full constructor. (Probabilities must be set separately).
     * 
     * @param coordinate
     *            original measurement.
     * @param time
     *            of the coordinate
     * @param id
     *            of the vehicle
     * @param spots
     *            map-matched spots this mapped to
     * @param probabilities
     * @param speed
     *            (can be null or greater than 0) in meters per second.
     * @param heading
     *            (can be null or 0 < heading < 360) in degrees.
     * @param hired
     *            (can be null) is this vehicle hired.
     * @param hdop
     *            (can be null or >= 1) horizontal dilution of position.
     * @throws NetconfigException
     *             on any error. This constructor performs a copy of the arrays,
     *             which may be safely reused or modified afterwards.
     */
    public static <LINK extends Link> ProbeCoordinate<LINK> from(String id,
            Time time, Coordinate coordinate, Spot<LINK>[] spots,
            double[] probabilities, Float speed, Short heading, Boolean hired,
            Float hdop) throws NetconfigException {
        // First check nulls.
        if (null == coordinate) {
            throw new NetconfigException(null, "Coordinate is null.");
        }

        if (null == time) {
            throw new NetconfigException(null, "Time cannot be null.");
        }

        if (null == id) {
            throw new NetconfigException(null, "Id cannot be null.");
        }
        ImmutableList<Spot<LINK>> spots_ = null;
        if (null == spots) {
            spots_ = ImmutableList.of();
        } else {
            for (Spot<LINK> s : spots) {
                if (null == s) {
                    throw new NetconfigException(null,
                            "Spots has at least one null element.");
                }
            }
            spots_ = ImmutableList.copyOf(spots);
        }

        ImmutableTensor1 probs = null;
        if (probabilities == null) {
            // Initialize the probabilities with uniform probabilities.
            probs = ImmutableTensor1.fillWith(1.0 / spots_.size(),
                    spots_.size());
        } else {
            probs = PathInference.buildProbabilities(probabilities);
        }

        if (spots_.size() != probs.size()) {
            throw new NetconfigException(null, "Spots has length "
                    + spots_.size() + " while probs has size " + probs.size());
        }

        // These can be null.
        if (null != speed && 0 > speed) {
            throw new NetconfigException(null, "Speed is negative.");
        }
        if (null != heading && (0 > heading || 360 < heading)) {
            throw new NetconfigException(null, "Heading is not [0,360].");
        }
        if (null != hdop && 1 > hdop) {
            throw new NetconfigException(null, "HDOP is less than 1.");
        }

        return new ProbeCoordinate<LINK>(id, time, coordinate, spots_, probs,
                speed, heading, hired, hdop);
    }

    public static <LINK extends Link> ProbeCoordinate<LINK> from(String id,
            Time time, Coordinate coordinate, Spot<LINK>[] spots, Float speed,
            Short heading, Boolean hired, Float hdop) throws NetconfigException {
        return from(id, time, coordinate, spots, null, speed, heading, hired,
                hdop);
    }

    public static <LINK extends Link> ProbeCoordinate<LINK> from(String id,
            Time time, Coordinate coordinate) throws NetconfigException {
        return from(id, time, coordinate, null, null, null, null, null, null);
    }

    /**
     * @return the id_
     */
    public String id() {
        return id_;
    }

    /**
     * @return the time_
     */
    public Time time() {
        return time_;
    }

    /**
     * @return the coordinate_
     */
    public Coordinate coordinate() {
        return coordinate_;
    }

    /**
     * @return the spots_
     */
    public ImmutableList<Spot<LINK>> spots() {
        return spots_;
    }

    /**
     * @return the probabilities_
     */
    public ImmutableTensor1 probabilities() {
        return probabilities_;
    }

    /**
     * @return the speed_
     */
    public Float speed() {
        return speed_;
    }

    /**
     * @return the heading_
     */
    public Short heading() {
        return heading_;
    }

    /**
     * @return the hired_
     */
    public Boolean hired() {
        return hired_;
    }

    /**
     * @return the hdop_
     */
    public Float hdop() {
        return hdop_;
    }

} // ProbeCoordinate
